<html>
	<head>
		<title>Tempmon</title>
	</head>
	
	<body>
		<div style="position:absolute; top:15px; left:15px; bottom:15px; right:15px;">
			<canvas id="theCanvas" style="width:100%; height:100%; border:1px solid rgba(255, 0, 0, 0.3);" tabindex="0">
				Your browser does not support the HTML5 canvas tag.
			</canvas>
		</div>
	</body>
	
	<script>
		'use strict';

		/*
			GraphDataPresenter
		*/
		function GraphDataPresenter() 
		{	
		}

		GraphDataPresenter.update = function( canvas, graphData, graphDataWindow )
		{
			canvas.width = canvas.clientWidth;
			canvas.height = canvas.clientHeight;

			var canvasWidth = canvas.width;
			var canvasHeight = canvas.height;
			var context = canvas.getContext("2d");
			
			// Grid lines
			var textSize = 14; 
			context.strokeStyle = "#CCCCCC";
			context.font = textSize + "px sans-serif";
			context.fillStyle="#CCCCCC";
			var c0 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:0, y:0}, graphDataWindow );
			var c1 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:1, y:1}, graphDataWindow );
			
			var dy = c1.y - c0.y;
			var yspacing = Math.pow( 10, Math.floor( Math.log10(dy) ) );   // in graph data unit
			var y0 = Math.floor( c0.y / yspacing ) * yspacing;
			var y1 = Math.floor( c1.y / yspacing ) * yspacing;
			for ( var y=y0; y<=y1; y+=yspacing )
			{
				context.beginPath();
				var windowPoint = GraphDataPresenter.graphDataPointToGraphWindowPoint( {x:0, y:y}, graphDataWindow );
				var canvasPoint = GraphDataPresenter.graphWindowPointToCanvasPoint( windowPoint, canvas );
				context.lineTo(0, canvasPoint.y);
				context.lineTo(canvasWidth, canvasPoint.y);
				context.stroke();
				var text = y;
				context.fillText(text, canvasWidth-context.measureText(text).width-5, canvasPoint.y-5);
			}

			var dx = c1.x - c0.x;
			var xspacing = Math.pow( 10, Math.floor( Math.log10(dx) ) );   // in graph data unit
			var x0 = Math.floor( c0.x / xspacing ) * xspacing;
			var x1 = Math.floor( c1.x / xspacing ) * xspacing;
			for ( var x=x0; x<=x1; x+=xspacing )
			{
				context.beginPath();
				var windowPoint = GraphDataPresenter.graphDataPointToGraphWindowPoint( {x:x, y:0}, graphDataWindow );
				var canvasPoint = GraphDataPresenter.graphWindowPointToCanvasPoint( windowPoint, canvas );
				context.lineTo(canvasPoint.x, 0);
				context.lineTo(canvasPoint.x, canvasHeight);
				context.stroke();
				var text = x;
				context.fillText(text, canvasPoint.x+5, textSize+2);
			}

			// Axes
			context.strokeStyle="#222222";
			var originwp = GraphDataPresenter.graphDataPointToGraphWindowPoint( {x:0, y:0}, graphDataWindow );
			var origincp = GraphDataPresenter.graphWindowPointToCanvasPoint( originwp, canvas );
			if ( originwp.y>=0 && originwp.y<=1 )
			{
				context.beginPath();	
				context.lineTo( 0, origincp.y );			
				context.lineTo( canvasWidth, origincp.y );	
				context.stroke();
			}
			if ( originwp.x>=0 && originwp.x<=1 )
			{
				context.beginPath();	
				context.lineTo( origincp.x, 0 );			
				context.lineTo( origincp.x, canvasHeight );	
				context.stroke();
			}
			
			// Data 
			context.beginPath();
			context.strokeStyle="#666666";
			context.fillStyle="#444444";
			for ( var i=0; i<graphData.length; i++ )
			{
				var windowPoint = GraphDataPresenter.graphDataPointToGraphWindowPoint( graphData[i], graphDataWindow );
				if ( GraphDataPresenter.isInUnitSquare(windowPoint) )
				{
					var canvasPoint = GraphDataPresenter.graphWindowPointToCanvasPoint( windowPoint, canvas );
					context.lineTo(canvasPoint.x, canvasPoint.y);
					context.fillRect(canvasPoint.x-2, canvasPoint.y-2, 4, 4);
				}
			}
			context.stroke();
		};

		GraphDataPresenter.isInUnitSquare = function( point )
		{
			if ( point.x<0 || point.y<0 || point.x>=1 || point.y>=1 )
				return false;
			return true;
		};

		GraphDataPresenter.graphDataPointToGraphWindowPoint = function( graphDataPoint, graphDataWindow )
		{
			var x2 = (graphDataPoint.x - graphDataWindow.x) / graphDataWindow.width;
			var y2 = (graphDataPoint.y - graphDataWindow.y) / graphDataWindow.height;
			return {x:x2, y:y2};
		};

		GraphDataPresenter.graphWindowPointToCanvasPoint = function( graphWindowPoint, canvas, roundToInteger )
		{
			var x2 = graphWindowPoint.x * canvas.width;
			var y2 = (1-graphWindowPoint.y) * canvas.height;
			if ( /*roundToInteger===undefined ||*/ roundToInteger )
			{
				x2 = Math.round(x2);
				y2 = Math.round(y2);
			}
			return {x:x2, y:y2};
		};

		GraphDataPresenter.canvasPointToGraphWindowPoint = function( canvasPoint, canvas )
		{
			var x2 = canvasPoint.x / canvas.width;
			var y2 = (canvas.height-canvasPoint.y) / canvas.height;
			return {x:x2, y:y2};
		};

		GraphDataPresenter.graphWindowPointToGraphDataPoint = function( graphWindowPoint, graphDataWindow )
		{
			var x2 = (graphWindowPoint.x * graphDataWindow.width) + graphDataWindow.x;
			var y2 = (graphWindowPoint.y * graphDataWindow.height) + graphDataWindow.y;
			return {x:x2, y:y2};
		};

		/*
			GraphController
		*/
		function GraphController( canvas, graphData, graphDataWindow ) 
		{	
			this._canvas = canvas;
			this._graphData = graphData;
			this._graphDataWindow = graphDataWindow;

			this._onKeyDownHandler = this._onKeyDown.bind(this);
			this._onMouseDownHandler = this._onMouseDown.bind(this);
			this._onMouseMoveHandler = this._onMouseMove.bind(this);
			this._onMouseUpHandler = this._onMouseUp.bind(this);
			this._onWheelHandler = this._onWheel.bind(this);

			this._canvas.addEventListener( 'keydown', this._onKeyDownHandler );
			this._canvas.addEventListener( 'mousedown', this._onMouseDownHandler );
			this._canvas.addEventListener( 'mousemove', this._onMouseMoveHandler );
			this._canvas.addEventListener( 'mouseup', this._onMouseUpHandler );
			this._canvas.addEventListener( 'wheel', this._onWheelHandler );
			
			this._lastCanvasPoint = null;
		}
		
		GraphController.prototype.dispose = function()
		{
			this._canvas.removeEventListener( 'keydown', this._onKeyDownHandler );
			this._canvas.removeEventListener( 'mousedown', this._onMouseDownHandler );
			this._canvas.removeEventListener( 'mousemove', this._onMouseMoveHandler );
			this._canvas.removeEventListener( 'mouseup', this._onMouseUpHandler );
			this._canvas.removeEventListener( 'wheel', this._onWheelHandler );
		};

		GraphController.prototype.update = function()
		{
			GraphDataPresenter.update( this._canvas, this._graphData, this._graphDataWindow );
		};

		GraphController._getCanvasPointFromEvent = function( event )
		{
			// The mouse position in the event happening on the canvas is relative to the whole document,
			// not the canvas. The "offset" properties is what we want, but it's not consistantly available 
			// on all browsers, so we calculate it here. See http://www.jacklmoore.com/notes/mouse-position/
			var target = event.target || event.srcElement;
			var rect = target.getBoundingClientRect();
			var offsetX = event.clientX - rect.left;
			var offsetY = event.clientY - rect.top;
			return {x:offsetX, y:offsetY};
		};

		GraphController.prototype._onKeyDown = function( event )
		{
			var c0 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:0, y:0}, this._graphDataWindow );
			var c1 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:1, y:1}, this._graphDataWindow );
			var s = 0.1;
			var dx = (c1.x - c0.x) * s;
			var dy = (c1.y - c0.y) * s;

			if ( event.keyCode===37 )				// left arrow
			{
				this._graphDataWindow.x -= dx;
			}
			else if ( event.keyCode===39 )			// right arrow
			{
				this._graphDataWindow.x += dx;
			}
			else if ( event.keyCode===38 )			// up arrow
			{
				this._graphDataWindow.y += dy;
			}
			else if ( event.keyCode===40 )			// down arrow
			{
				this._graphDataWindow.y -= dy;
			}
			else if ( event.keyCode===187 ||		// +/=
					  event.keyCode===189 )			// -/_
			{
				var zoomFactor = 1;
				var k = 0.1;
				if ( event.keyCode===187 )
				{	
					zoomFactor -= k;
				}
				else if ( event.keyCode===189 )
				{
					zoomFactor += k;
				}

				var graphDataPoint = {x:0.5, y:0.5};
				graphDataPoint = GraphDataPresenter.graphWindowPointToGraphDataPoint( graphDataPoint, this._graphDataWindow );

				this._graphDataWindow.width *= zoomFactor;
				this._graphDataWindow.height *= zoomFactor;

				var graphDataPoint2 = {x:0.5, y:0.5};
				graphDataPoint2 = GraphDataPresenter.graphWindowPointToGraphDataPoint( graphDataPoint2, this._graphDataWindow );

				this._graphDataWindow.x -= (graphDataPoint2.x - graphDataPoint.x);
				this._graphDataWindow.y -= (graphDataPoint2.y - graphDataPoint.y);
			}
			else if ( event.keyCode===189 )			// -/_
			{
				this._graphDataWindow.width *= 1.1;
				this._graphDataWindow.height *= 1.1;
			}

			this.update();
		};

		GraphController.prototype._onMouseDown = function( event )
		{
			this._lastCanvasPoint = GraphController._getCanvasPointFromEvent( event );
		};

		GraphController.prototype._onMouseMove = function( event )
		{
			if ( !this._lastCanvasPoint )
				return;

			var canvasPoint = GraphController._getCanvasPointFromEvent( event );

			var graphDataPoint = GraphDataPresenter.canvasPointToGraphWindowPoint( canvasPoint, this._canvas );
			graphDataPoint = GraphDataPresenter.graphWindowPointToGraphDataPoint( graphDataPoint, this._graphDataWindow );

			var lastGraphDataPoint = GraphDataPresenter.canvasPointToGraphWindowPoint( this._lastCanvasPoint, this._canvas );
			lastGraphDataPoint = GraphDataPresenter.graphWindowPointToGraphDataPoint( lastGraphDataPoint, this._graphDataWindow );

			var deltaX = graphDataPoint.x - lastGraphDataPoint.x;
			var deltaY = graphDataPoint.y - lastGraphDataPoint.y;
			this._graphDataWindow.x -= deltaX;
			this._graphDataWindow.y -= deltaY;

			this._lastCanvasPoint = canvasPoint;
		
			this.update();
		};

		GraphController.prototype._onMouseUp = function( event )
		{
			this._lastCanvasPoint = null;
		};

		GraphController.prototype._onWheel = function( event )
		{
			if ( event.ctrlKey )
			{
				var wheelDelta = 0;
				if ( Math.abs(event.deltaX)>Math.abs(event.deltaY) )
				{
					wheelDelta = event.deltaX;
				}
				else
				{
					wheelDelta = event.deltaY;
				}

				var canvasPoint = GraphController._getCanvasPointFromEvent( event );
			
				var	graphDataPoint = GraphDataPresenter.canvasPointToGraphWindowPoint( canvasPoint, this._canvas );
				graphDataPoint = GraphDataPresenter.graphWindowPointToGraphDataPoint( graphDataPoint, this._graphDataWindow );
				
				var zoomFactor = 1.0;
				var k = 0.001
				if ( wheelDelta>0 )
				{	
					zoomFactor += k;
				}
				else
				{
					zoomFactor -= k;
				}
				for ( var i=0; i<Math.abs(wheelDelta); ++i )
				{
					this._graphDataWindow.width *= zoomFactor;
					this._graphDataWindow.height *= zoomFactor;
				}

				var graphDataPoint2 = GraphDataPresenter.canvasPointToGraphWindowPoint( canvasPoint, this._canvas );
				graphDataPoint2 = GraphDataPresenter.graphWindowPointToGraphDataPoint( graphDataPoint2, this._graphDataWindow );
				this._graphDataWindow.x -= (graphDataPoint2.x - graphDataPoint.x);
				this._graphDataWindow.y -= (graphDataPoint2.y - graphDataPoint.y);
			}
			else
			{
				var c0 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:0, y:0}, this._graphDataWindow );
				var c1 = GraphDataPresenter.graphWindowPointToGraphDataPoint( {x:1, y:1}, this._graphDataWindow );
				var s = 0.001;					// Decent factor for OSX, might differ for other platform/browser 
				var dx = event.deltaX * (c1.x - c0.x) * s;
				var dy = event.deltaY * (c1.y - c0.y) * s;
				this._graphDataWindow.x += dx;	// Proper sign for OSX, might differ for other platform/browser 
				this._graphDataWindow.y -= dy;
			}

			this.update();
			
			event.preventDefault();
		};

		/*
			HttpRequest
		*/
		function HttpRequest()
		{
		}

		HttpRequest.request = function( url, method, data, headers )
		{
			var promise = new Promise(
				function(resolve, reject) 
				{
					var request = new XMLHttpRequest();
					request.open( method, url );
					if ( headers )
					{
						for ( var header in headers )
						{
							if ( headers.hasOwnProperty(header) )
							{
								request.setRequestHeader(header, headers[header]);
							}
						}
					}

					request.onload = function( event ) 	 
						{
							if ( request.status===200 )
							{
								resolve( request.response );
							}
							else
							{
								reject( new Error(request.status ) );
							}
						};

					request.onerror = function( event )		
						{
							reject( new Error(request.status ) );
						};
			
					try
					{
						request.send(data);
					}
					catch (exception)
					{
						reject( exception );
					}
				});
			return promise;
		};
		
		function main()
		{
			var createUint8ArrayFromMessageString = function( messageString )
				{
					// http://stackoverflow.com/questions/1597709/convert-a-string-with-a-hex-representation-of-an-ieee-754-double-into-javascript
					var messageLengthInBytes = 12;
					var buffer = new ArrayBuffer(messageLengthInBytes);
					var uint8Array = new Uint8Array( buffer );
					for ( var i=0; i<messageLengthInBytes; i++ )
					{
						var byteAsHex = messageString.substr( i*2, 2 );
						var byte = parseInt( byteAsHex, 16 );
						uint8Array[i] = byte;
					}
					return uint8Array;
				};

			var getWeatherDataFromUint8Array = function( uint8Array )
				{
					var dataView = new DataView(uint8Array.buffer);
					var weatherData = {
						pressure: dataView.getUint32(0),		
						temperature: dataView.getFloat32(4),
						humidity: dataView.getUint32(8)
					};
					return weatherData;
				};

			var canvas = document.getElementById('theCanvas');
			canvas.focus();
							
			var graphData = [];
			var graphDataWindow = {
				x: -20,		
				y: -5,
				width: 500,
				height: 50 
			};

			var graphController = new GraphController( canvas, graphData, graphDataWindow );
			graphController.update();

			HttpRequest.request( '/api/devices/1D80C/messages', 'GET')
				.then(
					function( response )
					{
						var messages = JSON.parse(response);
						for ( var i=0; i<messages.data.length; ++i  )
						{
							var message = messages.data[i];
							var numSecondsSinceEpoch = message.time;
							var date = new Date( numSecondsSinceEpoch * 1000 );
							var weatherData = getWeatherDataFromUint8Array( createUint8ArrayFromMessageString( message.data ) );

							// Store decoded data directly in the response object
							message.weatherData = weatherData;
							message.date = date;
						}

						// Test displaying the data. We convert time in minutes and rebase it ot the first value (of the first page for now)
						var t0 = messages.data[0].time;
						for ( var i=0; i<messages.data.length; ++i  )
						{
							var message = messages.data[i];
							graphData.push( {x:(message.time-t0) / 60, y:message.weatherData.temperature} );
						}
						
						graphController
					})
				.catch(
					function( error )
					{
						alert( error.toString() );
					});
		}

		main();

	</script>
	
</html>
